# React Server Components

React Server Components (RSC) are a new paradigm for building React applications where components can run on the server (or at build time) rather than in the browser.

## What Are Server Components?

Server Components are React components that:

- **Run on the server/build time** - Not in the browser
- **Can be async** - Use `async/await` directly in components
- **Have zero client bundle impact** - Their code never ships to the browser
- **Can access server-side resources** - Files, databases, environment variables

```tsx
// This component runs at build time, not in the browser
async function UserList() {
  // Direct file system access
  const data = await fs.readFile("./data/users.json", "utf-8");
  const users = JSON.parse(data);

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Server Components vs Client Components

| Feature | Server Components | Client Components |
|---------|------------------|-------------------|
| Runs on | Server/Build time | Browser |
| Can use hooks | No | Yes |
| Can use browser APIs | No | Yes |
| Can be async | Yes | No |
| Bundle size impact | Zero | Included |
| Data fetching | Direct | Via APIs |

## FUNSTACK Static and RSC

FUNSTACK Static leverages React Server Components for **static site generation**:

1. Components run at **build time** (not on a live server)
2. Output is **pure static HTML**
3. No JavaScript framework runtime shipped by default
4. Perfect for documentation, blogs, marketing sites

```tsx
// Build-time data fetching
async function BlogPost({ slug }: { slug: string }) {
  // Runs during build, not at runtime
  const content = await fetchMarkdownFile(`./posts/${slug}.md`);

  return (
    <article>
      <Markdown content={content} />
    </article>
  );
}
```

## Async Components

One of the most powerful features of Server Components is native async support:

```tsx
// No useEffect, no loading states - just async/await
async function WeatherWidget() {
  const weather = await fetch("https://api.weather.com/current")
    .then(r => r.json());

  return (
    <div>
      <span>{weather.temperature}Â°</span>
      <span>{weather.condition}</span>
    </div>
  );
}
```

> **Note:** In FUNSTACK Static, async data is fetched at build time. For truly dynamic data, you'll need client-side JavaScript.

## Composing Server and Client Components

While Server Components can't use hooks or browser APIs, they can render Client Components that do:

```tsx
// Server Component (runs at build time)
async function ProductPage({ id }: { id: string }) {
  const product = await fetchProduct(id);

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>

      {/* Client Component for interactivity */}
      <AddToCartButton productId={id} />
    </div>
  );
}
```

```tsx
// Client Component (runs in browser)
// Add "use client" directive at the top of your file

import { useState } from "react";

export function AddToCartButton({ productId }: { productId: string }) {
  const [added, setAdded] = useState(false);

  return (
    <button onClick={() => setAdded(true)}>
      {added ? "Added!" : "Add to Cart"}
    </button>
  );
}
```

## Benefits for Static Sites

### 1. Zero JavaScript by Default

Server Components render to HTML. No React runtime ships unless you add Client Components.

### 2. Build-Time Data Fetching

Fetch data once at build time, not on every page view:

```tsx
async function BlogIndex() {
  // Fetched once during build
  const posts = await fetchAllPosts();
  return <PostList posts={posts} />;
}
```

### 3. Direct File Access

Read files, parse markdown, process images - all at build time:

```tsx
async function Documentation() {
  const files = await glob("./docs/**/*.md");
  const docs = await Promise.all(
    files.map(f => parseMarkdown(f))
  );
  return <DocTree docs={docs} />;
}
```

### 4. Type-Safe Data Flow

Data flows from server to client with full TypeScript support:

```tsx
interface Post {
  id: string;
  title: string;
  content: string;
}

async function BlogPost({ slug }: { slug: string }): Promise<JSX.Element> {
  const post: Post = await fetchPost(slug);
  return <Article post={post} />;
}
```

## Limitations

When using FUNSTACK Static, keep in mind:

1. **Build-time only** - Data is fetched during build, not at runtime
2. **No request context** - No access to cookies, headers, or request data
3. **Static output** - Pages can't vary based on user or request

For dynamic features, combine static pages with client-side JavaScript or consider a server-rendered solution.

## See Also

- [Getting Started](/getting-started) - Set up your first project
- [defer()](/api/defer) - Stream content progressively
- [funstackStatic()](/api/funstack-static) - Plugin configuration
